From 9a7e4963ed09993d597cf719f088e6701a02db87 Mon Sep 17 00:00:00 2001
From: Roman Stratiienko <r.stratiienko@gmail.com>
Date: Fri, 30 Dec 2022 21:28:19 +0200
Subject: [PATCH 10/15] drM_hwcomposer: Squashed improvements

Signed-off-by: Roman Stratiienko <r.stratiienko@gmail.com>
---
 Android.bp                          |   6 +-
 architecture.md                     |  82 ++++++++
 backend/Backend.cpp                 | 168 ----------------
 backend/Backend.h                   |  42 ----
 backend/BackendClient.cpp           |  34 ----
 backend/BackendClient.h             |  27 ---
 backend/BackendManager.cpp          |  82 --------
 backend/BackendManager.h            |  55 ------
 compositor/CompositorBase.cpp       |  52 +++++
 compositor/CompositorBase.h         |  48 +++++
 compositor/CompositorClassic.cpp    | 285 ++++++++++++++++++++++++++++
 compositor/CompositorClassic.h      |  78 ++++++++
 compositor/FlatteningController.cpp |  83 ++++++++
 compositor/FlatteningController.h   |  70 +++++++
 hwc2_device/DrmHwcTwo.cpp           |   2 +-
 hwc2_device/HwcDisplay.cpp          | 207 +++++---------------
 hwc2_device/HwcDisplay.h            |  43 +----
 hwc2_device/HwcLayer.cpp            |   6 +-
 hwc2_device/HwcLayer.h              |   2 +-
 hwc2_device/hwc2_device.cpp         |   1 -
 meson.build                         |   5 +-
 21 files changed, 762 insertions(+), 616 deletions(-)
 create mode 100644 architecture.md
 delete mode 100644 backend/Backend.cpp
 delete mode 100644 backend/Backend.h
 delete mode 100644 backend/BackendClient.cpp
 delete mode 100644 backend/BackendClient.h
 delete mode 100644 backend/BackendManager.cpp
 delete mode 100644 backend/BackendManager.h
 create mode 100644 compositor/CompositorBase.cpp
 create mode 100644 compositor/CompositorBase.h
 create mode 100644 compositor/CompositorClassic.cpp
 create mode 100644 compositor/CompositorClassic.h
 create mode 100644 compositor/FlatteningController.cpp
 create mode 100644 compositor/FlatteningController.h

diff --git a/Android.bp b/Android.bp
index 8c4c95405d250d..7b4ffe1e35c7d4 100644
--- a/Android.bp
+++ b/Android.bp
@@ -59,6 +59,8 @@ filegroup {
         "bufferinfo/BufferInfoMapperMetadata.cpp",
         "bufferinfo/BufferInfoYagi.cpp",
 
+        "compositor/CompositorBase.cpp",
+        "compositor/CompositorClassic.cpp",
         "compositor/DrmKmsPlan.cpp",
         "compositor/FlatteningController.cpp",
 
@@ -76,10 +78,6 @@ filegroup {
         "drm/UEventListener.cpp",
         "drm/VSyncWorker.cpp",
 
-        "backend/Backend.cpp",
-        "backend/BackendClient.cpp",
-        "backend/BackendManager.cpp",
-
         "hwc2_device/DrmHwcTwo.cpp",
         "hwc2_device/HwcDisplay.cpp",
         "hwc2_device/HwcDisplayConfigs.cpp",
diff --git a/architecture.md b/architecture.md
new file mode 100644
index 00000000000000..dc84a98de80b33
--- /dev/null
+++ b/architecture.md
@@ -0,0 +1,82 @@
+## DRM Hardware Composer architecture
+
+### HWComposer diagram
+
+```s
+                        --- USERSPACE ---
++-------------------+
+| Android framework |    HWComposer internaly names it THE CLIENT
+|    (Userspace)    |    Usually it is the SurfaceFlinger service
++--+--------------+-+
+   |    Binder    |
+   |     API      |
++--v------------+ |      For HWC2.1-2.4 drm_hwcomposer
+|  Android HAL  | |      require external service app,
+|   Service     | |      which is provided by AOSP
++--+------------+ |
+   | dlopen       |
+   | /dlsym       |
++--v--------------v-+
+|   drm_hwcomposer  |    For HWC3, the drm_hwcomposer
+|                   |    implements the service
++--+----------------+
+   |
+   | Shared Library
++--v----------------+
+|  libdrm           |
+|                   |
++--+----------------+
+   |
+   | DRM IOCTL         --- KERNEL SPACE ---
++--v----------------+
+| Kernel DRM/KMS    |
+| Driver            |
++--+----------------+
+   |
+   | REGMAP
++--v----------------+
+| Display pipeline  |
+| Hardware Registers|
++-------------------+
+
+```
+
+### drm_hwcomposer software block diagram
+```s
++- - - - - - - - - +
+.    HWC 2.1-2.4   . HWC2 Service is a part of AOSP
+.      Service     . (hardware/interfaces/graphics/composer/)
++- - - - -+- - - - +
+          |
+          |
++---------v--------+      +----------------+        +--------------+    +---+
+|  HWC2 hw_module  |      |  HWC3 Service  |        |              |    |   |
+|     frontend     |  OR  |    frontend    |        |  BufferInfo  + - -|   |
+|                  |      |                |        |              |    |   |
++---------+--------+      +-------+--------+        +--------------+    | R |
+          |                       |                                     | E |
+          |   +-------------------+                   TO FRONTEND   <---+ S |
+          |   |                                                         | O |
++---------v---v----+---------------+---------------+---------------+    | U |
+|                  |  Compositor   |  Compositer   |     More      |    | R |
+|    Compositor    |  Generic      |  Client       |  compositors  |    | C |
+|                  |  Backend      |  Backend      |     ...       |    | E |
++-----------+------+---------------+---------------+---------------+    |   |
+            |                                                           | M |
+            |                                                           | A |
++-----------v-----------+           +------------------------------+    | N |
+|                       |           |      DrmDisplayPipeline      |    | A |
+| DrmAtomicStateManager | - - - - - | (One per DRM Device / CRTC)  + - -| G |
+|                       |           |                              |    | E |
++-----------------------+           +------------------------------+    | R |
+            |                                      .                    |   |
+            |                                      .                    |   |
++-----------v-----------+           +------------------------------+    |   |
+|                       |           |         DRM Device           |    |   |
+|        libdrm         | - - - - - |    (One per /dev/cardX)      + - -|   |
+|                       |           |                              |    |   |
++-----------+-----------+           +------------------------------+    +---+
+            |
+            v
+      DRM/KMS IOCTLs
+```
diff --git a/backend/Backend.cpp b/backend/Backend.cpp
deleted file mode 100644
index ad823562f21492..00000000000000
--- a/backend/Backend.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "Backend.h"
-
-#include <climits>
-
-#include "BackendManager.h"
-#include "bufferinfo/BufferInfoGetter.h"
-
-namespace android {
-
-void Backend::ValidateComposition(FEComposition &comp) {
-  int client_start = -1;
-  size_t client_size = 0;
-
-  // NOLINTNEXTLINE(): Temporary workaround
-  auto &display = static_cast<HwcDisplay &>(comp);
-
-  auto layers = GetOrderedLayers(comp, &client_start, &client_size);
-
-  auto flatcon = display.GetFlatCon();
-  if (flatcon) {
-    bool should_flatten = false;
-    if (layers.size() <= 1)
-      flatcon->Disable();
-    else
-      should_flatten = flatcon->NewFrame();
-
-    if (should_flatten) {
-      display.total_stats().frames_flattened_++;
-      client_start = 0;
-      client_size = layers.size();
-      MarkClient(layers, client_start, client_size);
-      return;
-    }
-  }
-
-  ExtendClientRange(display, layers, std::ref(client_start),
-                    std::ref(client_size));
-
-  MarkClient(layers, client_start, client_size);
-
-  auto testing_needed = client_start != 0 || client_size != layers.size();
-
-  AtomicCommitArgs a_args = {.test_only = true};
-
-  if (testing_needed &&
-      display.CreateComposition(a_args) != HWC2::Error::None) {
-    ++display.total_stats().failed_kms_validate_;
-    client_start = 0;
-    client_size = layers.size();
-    MarkClient(layers, 0, client_size);
-  }
-
-  display.total_stats().gpu_pixops_ += CalcPixOps(layers, client_start,
-                                                  client_size);
-  display.total_stats().total_pixops_ += CalcPixOps(layers, 0, layers.size());
-}
-
-auto Backend::CalcPixOps(OrderedLayers &layers, size_t first_z, size_t size)
-    -> uint32_t {
-  uint32_t pixops = 0;
-  int i = 0;
-  for (auto &l : layers) {
-    if (i >= first_z && i < first_z + size) {
-      auto &df = l.second->layer_data.pi.display_frame;
-      pixops += (df.right - df.left) * (df.bottom - df.top);
-    }
-    i++;
-  }
-  return pixops;
-}
-
-void Backend::MarkClient(OrderedLayers &layers, size_t client_first_z,
-                         size_t client_size) {
-  int i = 0;
-  for (auto &l : layers) {
-    if (i >= client_first_z && i < client_first_z + client_size) {
-      l.second->use_client = true;
-    }
-    i++;
-  }
-}
-
-void Backend::ExtendClientRange(HwcDisplay &display, OrderedLayers &layers,
-                                int &client_start, size_t &client_size) {
-  auto planes = display.GetPipe().GetUsablePlanes();
-  size_t avail_planes = planes.size();
-
-  /*
-   * If more layers than planes, save one plane
-   * for client composited layers
-   */
-  if (avail_planes < layers.size())
-    avail_planes--;
-
-  const int extra_client = int(layers.size() - client_size) - int(avail_planes);
-
-  if (extra_client > 0) {
-    int start = 0;
-    size_t steps = 0;
-    if (client_size != 0) {
-      const int prepend = std::min(client_start, extra_client);
-      const int append = std::min(int(layers.size()) -
-                                      int(client_start + client_size),
-                                  extra_client);
-      start = client_start - (int)prepend;
-      client_size += extra_client;
-      steps = 1 + std::min(std::min(append, prepend),
-                           int(layers.size()) - int(start + client_size));
-    } else {
-      client_size = extra_client;
-      steps = 1 + layers.size() - extra_client;
-    }
-
-    uint32_t gpu_pixops = UINT32_MAX;
-    for (size_t i = 0; i < steps; i++) {
-      const uint32_t po = CalcPixOps(layers, start + i, client_size);
-      if (po < gpu_pixops) {
-        gpu_pixops = po;
-        client_start = start + int(i);
-      }
-    }
-  }
-}
-
-auto Backend::GetOrderedLayers(FEComposition &comp, int *out_client_start,
-                               size_t *out_client_size) -> OrderedLayers {
-  int client_start = -1;
-  size_t client_size = 0;
-
-  OrderedLayers ordered;
-
-  for (auto &fl : comp.fe_layers) {
-    ordered.emplace(fl.second->zpos, fl.second);
-    if (fl.second->use_client) {
-      if (client_start < 0)
-        client_start = (int)fl.second->zpos;
-      client_size = (fl.second->zpos - client_start) + 1;
-    }
-  }
-
-  *out_client_start = client_start;
-  *out_client_size = client_size;
-
-  return ordered;
-}
-
-// clang-format off
-// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables, cert-err58-cpp)
-REGISTER_BACKEND("generic", Backend);
-// clang-format on
-
-}  // namespace android
diff --git a/backend/Backend.h b/backend/Backend.h
deleted file mode 100644
index 6cf2e27a88ddd0..00000000000000
--- a/backend/Backend.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "compositor/FEComposition.h"
-#include "hwc2_device/DrmHwcTwo.h"
-
-namespace android {
-
-using OrderedLayers = std::multimap<uint32_t /*z_pos*/,
-                                    std::shared_ptr<FELayer>>;
-
-class Backend {
- public:
-  virtual ~Backend() = default;
-  virtual void ValidateComposition(FEComposition &comp);
-
- protected:
-  static auto CalcPixOps(OrderedLayers &layers, size_t first_z, size_t size)
-      -> uint32_t;
-  static void MarkClient(OrderedLayers &layers, size_t client_first_z,
-                         size_t client_size);
-  static void ExtendClientRange(HwcDisplay &display, OrderedLayers &layers,
-                                int &client_start, size_t &client_size);
-  static auto GetOrderedLayers(FEComposition &comp, int *out_client_start,
-                               size_t *out_client_size) -> OrderedLayers;
-};
-}  // namespace android
diff --git a/backend/BackendClient.cpp b/backend/BackendClient.cpp
deleted file mode 100644
index 40744ca51cc99f..00000000000000
--- a/backend/BackendClient.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "BackendClient.h"
-
-#include "BackendManager.h"
-
-namespace android {
-
-void BackendClient::ValidateComposition(FEComposition &comp) {
-  for (auto &fl : comp.fe_layers) {
-    fl.second->use_client = true;
-  }
-}
-
-// clang-format off
-// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables, cert-err58-cpp)
-REGISTER_BACKEND("client", BackendClient);
-// clang-format on
-
-}  // namespace android
diff --git a/backend/BackendClient.h b/backend/BackendClient.h
deleted file mode 100644
index 1cdb902deae0a2..00000000000000
--- a/backend/BackendClient.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "Backend.h"
-
-namespace android {
-
-class BackendClient : public Backend {
- public:
-  void ValidateComposition(FEComposition &comp) override;
-};
-}  // namespace android
diff --git a/backend/BackendManager.cpp b/backend/BackendManager.cpp
deleted file mode 100644
index c1bc0f6af711e6..00000000000000
--- a/backend/BackendManager.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "hwc-backend"
-
-#include "BackendManager.h"
-
-#include "utils/log.h"
-#include "utils/properties.h"
-
-namespace android {
-
-// NOLINTNEXTLINE(cert-err58-cpp)
-const std::vector<std::string> BackendManager::kClientDevices = {
-    "kirin",
-    "mediatek-drm",
-};
-
-BackendManager &BackendManager::GetInstance() {
-  static BackendManager backend_manager;
-
-  return backend_manager;
-}
-
-int BackendManager::RegisterBackend(const std::string &name,
-                                    BackendConstructorT backend_constructor) {
-  available_backends_[name] = std::move(backend_constructor);
-  return 0;
-}
-
-int BackendManager::SetBackendForDisplay(HwcDisplay *display) {
-  auto driver_name(display->GetPipe().device->GetName());
-  char backend_override[PROPERTY_VALUE_MAX];
-  property_get("vendor.hwc.backend_override", backend_override,
-               driver_name.c_str());
-  std::string backend_name(backend_override);
-
-  display->set_backend(GetBackendByName(backend_name));
-  if (display->backend() == nullptr) {
-    ALOGE("Failed to set backend '%s' for '%s' and driver '%s'",
-          backend_name.c_str(),
-          display->GetPipe().connector->Get()->GetName().c_str(),
-          driver_name.c_str());
-    return -EINVAL;
-  }
-
-  ALOGI("Backend '%s' for '%s' and driver '%s' was successfully set",
-        backend_name.c_str(),
-        display->GetPipe().connector->Get()->GetName().c_str(),
-        driver_name.c_str());
-
-  return 0;
-}
-
-std::unique_ptr<Backend> BackendManager::GetBackendByName(std::string &name) {
-  if (available_backends_.empty()) {
-    ALOGE("No backends are specified");
-    return nullptr;
-  }
-
-  auto it = available_backends_.find(name);
-  if (it == available_backends_.end()) {
-    auto it = std::find(kClientDevices.begin(), kClientDevices.end(), name);
-    name = it == kClientDevices.end() ? "generic" : "client";
-  }
-
-  return available_backends_[name]();
-}
-}  // namespace android
diff --git a/backend/BackendManager.h b/backend/BackendManager.h
deleted file mode 100644
index 49767442ad6458..00000000000000
--- a/backend/BackendManager.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <functional>
-#include <map>
-#include <string>
-#include <vector>
-
-#include "Backend.h"
-
-// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
-#define REGISTER_BACKEND(name_str_, backend_)                               \
-  static int                                                                \
-      backend = BackendManager::GetInstance()                               \
-                    .RegisterBackend(name_str_,                             \
-                                     []() -> std::unique_ptr<Backend> {     \
-                                       return std::make_unique<backend_>(); \
-                                     });
-
-namespace android {
-
-class BackendManager {
- public:
-  using BackendConstructorT = std::function<std::unique_ptr<Backend>()>;
-  static BackendManager &GetInstance();
-  int RegisterBackend(const std::string &name,
-                      BackendConstructorT backend_constructor);
-  int SetBackendForDisplay(HwcDisplay *display);
-  std::unique_ptr<Backend> GetBackendByName(std::string &name);
-  HWC2::Error ValidateDisplay(HwcDisplay *display, uint32_t *num_types,
-                              uint32_t *num_requests);
-
- private:
-  BackendManager() = default;
-
-  static const std::vector<std::string> kClientDevices;
-
-  std::map<std::string, BackendConstructorT> available_backends_;
-};
-}  // namespace android
diff --git a/compositor/CompositorBase.cpp b/compositor/CompositorBase.cpp
new file mode 100644
index 00000000000000..74d5914643f098
--- /dev/null
+++ b/compositor/CompositorBase.cpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "hwc-compositior-base"
+
+#include "CompositorBase.h"
+
+#include "CompositorClassic.h"
+#include "bufferinfo/BufferInfoGetter.h"
+#include "utils/properties.h"
+
+namespace android {
+
+const std::map<std::string,
+               std::function<decltype(CompositorClient::CreateInstance)>>
+    // NOLINTNEXTLINE(cert-err58-cpp)
+    kCompositors = {
+        {"kirin", CompositorClient::CreateInstance},
+        {"mediatek-drm", CompositorClient::CreateInstance},
+        {"generic", CompositorGeneric::CreateInstance},
+        {"client", CompositorClient::CreateInstance},
+};
+
+auto CompositorBase::FindAndCreate(DrmDisplayPipeline &pipe,
+                                   CompositorCallbacks &cbks)
+    -> std::unique_ptr<CompositorBase> {
+  auto driver_name(pipe.device->GetName());
+  char backend_override[PROPERTY_VALUE_MAX];
+  property_get("vendor.hwc.backend_override", backend_override,
+               driver_name.c_str());
+
+  if (kCompositors.count(backend_override) == 0) {
+    return CompositorGeneric::CreateInstance(pipe, cbks);
+  }
+
+  return kCompositors.at(std::string(backend_override))(pipe, cbks);
+}
+
+}  // namespace android
diff --git a/compositor/CompositorBase.h b/compositor/CompositorBase.h
new file mode 100644
index 00000000000000..b0af72d693e726
--- /dev/null
+++ b/compositor/CompositorBase.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "FEComposition.h"
+#include "drm/DrmAtomicStateManager.h"
+#include "drm/DrmDisplayPipeline.h"
+
+namespace android {
+
+struct CompositorCallbacks {
+  /* Update layer internal state with new info. This implies importing the
+   * buffer. Returns true if layer successfully imported and can be futher
+   * processed.
+   */
+  std::function<bool(FELayer &, bool /*test_only*/)> update_layer_data;
+  /* Retriggers client validate/present cycle */
+  std::function<void()> update_composition;
+};
+
+struct CompositorBase {
+  static auto FindAndCreate(DrmDisplayPipeline &pipe, CompositorCallbacks &cbks)
+      -> std::unique_ptr<CompositorBase>;
+
+  virtual void ValidateComposition(FEComposition &comp);
+  virtual auto PresentComposition(FEComposition &comp, AtomicCommitArgs &a_args)
+      -> int;
+  virtual auto Dump() -> std::string;
+
+  CompositorBase() = default;
+  virtual ~CompositorBase() = default;
+};
+
+}  // namespace android
diff --git a/compositor/CompositorClassic.cpp b/compositor/CompositorClassic.cpp
new file mode 100644
index 00000000000000..65eefd69ff2e62
--- /dev/null
+++ b/compositor/CompositorClassic.cpp
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "hwc-compositior-classic"
+
+#include "CompositorClassic.h"
+
+#include <sstream>
+
+namespace android {
+
+auto CompositorClient::CreateInstance(DrmDisplayPipeline &pipe,
+                                      CompositorCallbacks &cbks)
+    -> std::unique_ptr<CompositorBase> {
+  return std::unique_ptr<CompositorBase>(new CompositorClient(pipe, cbks));
+}
+
+void CompositorClient::ValidateComposition(FEComposition &comp) {
+  for (auto &fl : comp.fe_layers) {
+    fl.second->use_client = true;
+  }
+}
+
+auto CompositorGeneric::CreateInstance(DrmDisplayPipeline &pipe,
+                                       CompositorCallbacks &cbks)
+    -> std::unique_ptr<CompositorBase> {
+  return std::unique_ptr<CompositorBase>(new CompositorGeneric(pipe, cbks));
+}
+
+CompositorGeneric::CompositorGeneric(DrmDisplayPipeline &pipe,
+                                     CompositorCallbacks &cbks) {
+  if (cbks.update_composition) {
+    auto flatcbk = (struct FlatConCallbacks){
+        .trigger = cbks.update_composition,
+    };
+    flatcon_ = FlatteningController::CreateInstance(flatcbk);
+  }
+  cbks_ = cbks;
+  pipe_ = &pipe;
+}
+
+CompositorGeneric::~CompositorGeneric() {
+  if (flatcon_)
+    flatcon_->StopThread();
+}
+
+void CompositorGeneric::ValidateComposition(FEComposition &comp) {
+  int client_start = -1;
+  size_t client_size = 0;
+
+  stat_.total_frames++;
+
+  auto layers = GetOrderedLayers(comp, &client_start, &client_size);
+
+  if (flatcon_) {
+    bool should_flatten = false;
+    if (layers.size() <= 1)
+      flatcon_->Disable();
+    else
+      should_flatten = flatcon_->NewFrame();
+
+    if (should_flatten) {
+      stat_.frames_flattened++;
+      client_start = 0;
+      client_size = layers.size();
+      MarkClient(layers, client_start, client_size);
+      return;
+    }
+  }
+
+  ExtendClientRange(layers, std::ref(client_start), std::ref(client_size));
+
+  MarkClient(layers, client_start, client_size);
+
+  auto testing_needed = client_start != 0 || client_size != layers.size();
+
+  AtomicCommitArgs a_args = {.test_only = true};
+
+  if (testing_needed && PresentComposition(comp, a_args) != 0) {
+    stat_.failed_validate++;
+    client_start = 0;
+    client_size = layers.size();
+    MarkClient(layers, 0, client_size);
+  }
+
+  stat_.gpu_pixops += CalcPixOps(layers, client_start, client_size);
+  stat_.total_pixops += CalcPixOps(layers, 0, layers.size());
+}
+
+auto CompositorGeneric::PresentComposition(FEComposition &comp,
+                                           AtomicCommitArgs &a_args) -> int {
+  int client_start = -1;
+  size_t client_size = 0;
+
+  auto layers = GetOrderedLayers(comp, &client_start, &client_size);
+
+  if (client_size > 0)
+    layers.emplace(client_start, comp.client_output);
+
+  if (layers.empty())
+    return -EINVAL;
+
+  std::vector<LayerData> composition_layers;
+
+  // now that they're ordered by z, add them to the composition
+  for (auto &ol : layers) {
+    if (ol.second->use_client)
+      continue;
+
+    /* Import & populate */
+    if (!cbks_.update_layer_data(*ol.second, a_args.test_only)) {
+      /* This will be normally triggered on validation of the first frame
+       * containing CLIENT layer. At this moment client buffer is not yet
+       * provided by the CLIENT.
+       * This may be triggered once in HwcLayer lifecycle in case FB can't be
+       * imported. For example when non-contiguous buffer is imported into
+       * contiguous-only DRM/KMS driver.
+       */
+      if (!a_args.test_only)
+        stat_.failed_present++;
+      return -EINVAL;
+    }
+    composition_layers.emplace_back(ol.second->layer_data.Clone());
+  }
+
+  /* Store plan to ensure shared planes won't be stolen by other display
+   * in between of ValidateDisplay() and PresentDisplay() calls
+   */
+  current_plan_ = DrmKmsPlan::CreateDrmKmsPlan(*pipe_,
+                                               std::move(composition_layers));
+  if (!current_plan_) {
+    if (!a_args.test_only) {
+      ALOGE("Failed to create DrmKmsPlan");
+      stat_.failed_present++;
+    }
+    return -EINVAL;
+  }
+
+  a_args.composition = current_plan_;
+
+  auto ret = pipe_->atomic_state_manager->ExecuteAtomicCommit(a_args);
+
+  if (ret != 0) {
+    if (!a_args.test_only) {
+      ALOGE("Failed to apply the frame composition ret=%d", ret);
+      stat_.failed_present++;
+    }
+    return ret;
+  }
+
+  return 0;
+}
+
+auto CompositorGeneric::CalcPixOps(OrderedLayers &layers, size_t first_z,
+                                   size_t size) -> uint32_t {
+  uint32_t pixops = 0;
+  size_t i = 0;
+  for (auto &l : layers) {
+    if (i >= first_z && i < first_z + size) {
+      auto &df = l.second->layer_data.pi.display_frame;
+      pixops += (df.right - df.left) * (df.bottom - df.top);
+    }
+    i++;
+  }
+  return pixops;
+}
+
+void CompositorGeneric::MarkClient(OrderedLayers &layers, size_t client_first_z,
+                                   size_t client_size) {
+  size_t i = 0;
+  for (auto &l : layers) {
+    if (i >= client_first_z && i < client_first_z + client_size) {
+      l.second->use_client = true;
+    }
+    i++;
+  }
+}
+
+void CompositorGeneric::ExtendClientRange(OrderedLayers &layers,
+                                          int &client_start,
+                                          size_t &client_size) {
+  auto planes = pipe_->GetUsablePlanes();
+  size_t avail_planes = planes.size();
+
+  /*
+   * If more layers than planes, save one plane
+   * for client composited layers
+   */
+  if (avail_planes < layers.size())
+    avail_planes--;
+
+  const int extra_client = int(layers.size() - client_size) - int(avail_planes);
+
+  if (extra_client > 0) {
+    int start = 0;
+    size_t steps = 0;
+    if (client_size != 0) {
+      const int prepend = std::min(client_start, extra_client);
+      const int append = std::min(int(layers.size()) -
+                                      int(client_start + client_size),
+                                  extra_client);
+      start = client_start - (int)prepend;
+      client_size += extra_client;
+      steps = 1 + std::min(std::min(append, prepend),
+                           int(layers.size()) - int(start + client_size));
+    } else {
+      client_size = extra_client;
+      steps = 1 + layers.size() - extra_client;
+    }
+
+    uint32_t gpu_pixops = UINT32_MAX;
+    for (size_t i = 0; i < steps; i++) {
+      const uint32_t po = CalcPixOps(layers, start + i, client_size);
+      if (po < gpu_pixops) {
+        gpu_pixops = po;
+        client_start = start + int(i);
+      }
+    }
+  }
+}
+
+auto CompositorGeneric::GetOrderedLayers(FEComposition &comp,
+                                         int *out_client_start,
+                                         size_t *out_client_size)
+    -> OrderedLayers {
+  int client_start = -1;
+  size_t client_size = 0;
+
+  OrderedLayers ordered;
+
+  for (auto &fl : comp.fe_layers)
+    ordered.emplace(fl.second->zpos, fl.second);
+
+  int i = 0;
+  for (auto &ol : ordered) {
+    if (ol.second->use_client) {
+      if (client_start < 0)
+        client_start = i;
+      client_size = (i - client_start) + 1;
+    }
+    i++;
+  }
+
+  *out_client_start = client_start;
+  *out_client_size = client_size;
+
+  return ordered;
+}
+
+auto CompositorGeneric::Dump() -> std::string {
+  if (stat_.total_pixops == 0)
+    return "No stats yet";
+
+  // NOLINTNEXTLINE(readability-magic-numbers):
+  auto ratio = 1.0 - double(stat_.gpu_pixops) / double(stat_.total_pixops);
+
+  std::stringstream ss;
+  ss << " Total frames count: " << stat_.total_frames << "\n";
+  ss << " Validate fail count: " << stat_.failed_validate << "\n";
+  ss << " Present fail count: " << stat_.failed_present << "\n";
+  if (stat_.failed_present > 0)
+    ss << " !!! Internal failure, FIX it please\n";
+
+  ss << " Flattened frames: " << stat_.frames_flattened << "\n";
+  ss << " Pixel operations (free units)";
+  ss << " : [TOTAL: " << stat_.total_pixops << " / GPU: " << stat_.gpu_pixops;
+  ss << "]\n";
+  ss << " Composition efficiency: " << ratio;
+
+  return ss.str();
+}
+
+}  // namespace android
diff --git a/compositor/CompositorClassic.h b/compositor/CompositorClassic.h
new file mode 100644
index 00000000000000..ce11b65df16e1e
--- /dev/null
+++ b/compositor/CompositorClassic.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "CompositorBase.h"
+#include "DrmKmsPlan.h"
+#include "FlatteningController.h"
+
+namespace android {
+
+using OrderedLayers = std::multimap<uint32_t /*z_pos*/,
+                                    std::shared_ptr<FELayer>>;
+
+struct CompositorStat {
+  uint64_t total_pixops, gpu_pixops;
+  uint64_t failed_validate, failed_present;
+  uint64_t total_frames, frames_flattened;
+};
+
+class CompositorGeneric : public CompositorBase {
+ public:
+  static auto CreateInstance(DrmDisplayPipeline &pipe,
+                             CompositorCallbacks &cbks)
+      -> std::unique_ptr<CompositorBase>;
+
+  CompositorGeneric(DrmDisplayPipeline &pipe, CompositorCallbacks &cbks);
+  ~CompositorGeneric() override;
+
+  void ValidateComposition(FEComposition &comp) override;
+  auto PresentComposition(FEComposition &comp, AtomicCommitArgs &a_args)
+      -> int override;
+  auto Dump() -> std::string override;
+
+ protected:
+  static auto CalcPixOps(OrderedLayers &layers, size_t first_z, size_t size)
+      -> uint32_t;
+  static void MarkClient(OrderedLayers &layers, size_t client_first_z,
+                         size_t client_size);
+  void ExtendClientRange(OrderedLayers &layers, int &client_start,
+                         size_t &client_size);
+  static auto GetOrderedLayers(FEComposition &comp, int *out_client_start,
+                               size_t *out_client_size) -> OrderedLayers;
+
+ private:
+  std::shared_ptr<DrmKmsPlan> current_plan_;
+  std::shared_ptr<FlatteningController> flatcon_;
+  CompositorStat stat_{};
+  CompositorCallbacks cbks_;
+  DrmDisplayPipeline *pipe_{};
+};
+
+/*
+ * All composition is done by the CLIENT (SurfaceFlinger using GLES)
+ */
+class CompositorClient : public CompositorGeneric {
+ public:
+  using CompositorGeneric::CompositorGeneric;
+  static auto CreateInstance(DrmDisplayPipeline &pipe,
+                             CompositorCallbacks &cbks)
+      -> std::unique_ptr<CompositorBase>;
+
+  void ValidateComposition(FEComposition &comp) override;
+};
+}  // namespace android
diff --git a/compositor/FlatteningController.cpp b/compositor/FlatteningController.cpp
new file mode 100644
index 00000000000000..18fa4206bb6553
--- /dev/null
+++ b/compositor/FlatteningController.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "hwc-flatcon"
+
+#include "FlatteningController.h"
+
+#include "utils/log.h"
+
+namespace android {
+
+auto FlatteningController::CreateInstance(FlatConCallbacks &cbks)
+    -> std::shared_ptr<FlatteningController> {
+  auto fc = std::shared_ptr<FlatteningController>(new FlatteningController());
+
+  fc->cbks_ = cbks;
+
+  std::thread(&FlatteningController::ThreadFn, fc).detach();
+
+  return fc;
+}
+
+/* Compositor should call this every frame */
+bool FlatteningController::NewFrame() {
+  bool wake_it = false;
+  auto lock = std::lock_guard<std::mutex>(mutex_);
+
+  if (flatten_next_frame_) {
+    flatten_next_frame_ = false;
+    return true;
+  }
+
+  sleep_until_ = std::chrono::system_clock::now() + kTimeout;
+  if (disabled_) {
+    wake_it = true;
+    disabled_ = false;
+  }
+
+  if (wake_it)
+    cv_.notify_all();
+
+  return false;
+}
+
+void FlatteningController::ThreadFn(
+    const std::shared_ptr<FlatteningController> &fc) {
+  for (;;) {
+    std::unique_lock<std::mutex> lock(fc->mutex_);
+    if (fc.use_count() == 1 || !fc->cbks_.trigger)
+      break;
+
+    if (fc->sleep_until_ <= std::chrono::system_clock::now() &&
+        !fc->disabled_) {
+      fc->disabled_ = true;
+      fc->flatten_next_frame_ = true;
+      ALOGV("Timeout. Sending an event to compositor");
+      fc->cbks_.trigger();
+    }
+
+    if (fc->disabled_) {
+      ALOGV("Wait");
+      fc->cv_.wait(lock);
+    } else {
+      ALOGV("Wait_until");
+      fc->cv_.wait_until(lock, fc->sleep_until_);
+    }
+  }
+}
+
+}  // namespace android
diff --git a/compositor/FlatteningController.h b/compositor/FlatteningController.h
new file mode 100644
index 00000000000000..9a7d6ec254b1c0
--- /dev/null
+++ b/compositor/FlatteningController.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <condition_variable>
+#include <thread>
+
+namespace android {
+
+// NOLINTNEXTLINE(misc-unused-using-decls): False positive
+using std::chrono_literals::operator""s;
+
+struct FlatConCallbacks {
+  std::function<void()> trigger;
+};
+
+class FlatteningController {
+ public:
+  static auto CreateInstance(FlatConCallbacks &cbks)
+      -> std::shared_ptr<FlatteningController>;
+
+  void Disable() {
+    auto lock = std::lock_guard<std::mutex>(mutex_);
+    flatten_next_frame_ = false;
+    disabled_ = true;
+  }
+
+  /* Compositor should call this every frame */
+  bool NewFrame();
+
+  auto ShouldFlatten() const {
+    return flatten_next_frame_;
+  }
+
+  void StopThread() {
+    auto lock = std::lock_guard<std::mutex>(mutex_);
+    cbks_ = {};
+    cv_.notify_all();
+  }
+
+  static constexpr auto kTimeout = 1s;
+
+ private:
+  FlatteningController() = default;
+  static void ThreadFn(const std::shared_ptr<FlatteningController> &fc);
+
+  bool flatten_next_frame_{};
+  bool disabled_{};
+  decltype(std::chrono::system_clock::now()) sleep_until_{};
+  std::mutex mutex_;
+  std::condition_variable cv_;
+  FlatConCallbacks cbks_;
+};
+
+}  // namespace android
diff --git a/hwc2_device/DrmHwcTwo.cpp b/hwc2_device/DrmHwcTwo.cpp
index 64755c34580be3..c094efd0882cfe 100644
--- a/hwc2_device/DrmHwcTwo.cpp
+++ b/hwc2_device/DrmHwcTwo.cpp
@@ -20,7 +20,7 @@
 
 #include <cinttypes>
 
-#include "backend/Backend.h"
+#include "compositor/CompositorBase.h"
 #include "utils/log.h"
 
 namespace android {
diff --git a/hwc2_device/HwcDisplay.cpp b/hwc2_device/HwcDisplay.cpp
index 62011c38485b13..717806b1e07e3b 100644
--- a/hwc2_device/HwcDisplay.cpp
+++ b/hwc2_device/HwcDisplay.cpp
@@ -20,48 +20,44 @@
 #include "HwcDisplay.h"
 
 #include "DrmHwcTwo.h"
-#include "backend/Backend.h"
-#include "backend/BackendManager.h"
 #include "bufferinfo/BufferInfoGetter.h"
+#include "compositor/CompositorBase.h"
 #include "utils/log.h"
 #include "utils/properties.h"
 
 namespace android {
 
-std::string HwcDisplay::DumpDelta(HwcDisplay::Stats delta) {
-  if (delta.total_pixops_ == 0)
-    return "No stats yet";
-  auto ratio = 1.0 - double(delta.gpu_pixops_) / double(delta.total_pixops_);
-
-  std::stringstream ss;
-  ss << " Total frames count: " << delta.total_frames_ << "\n"
-     << " Failed to test commit frames: " << delta.failed_kms_validate_ << "\n"
-     << " Failed to commit frames: " << delta.failed_kms_present_ << "\n"
-     << ((delta.failed_kms_present_ > 0)
-             ? " !!! Internal failure, FIX it please\n"
-             : "")
-     << " Flattened frames: " << delta.frames_flattened_ << "\n"
-     << " Pixel operations (free units)"
-     << " : [TOTAL: " << delta.total_pixops_ << " / GPU: " << delta.gpu_pixops_
-     << "]\n"
-     << " Composition efficiency: " << ratio;
-
-  return ss.str();
-}
-
 std::string HwcDisplay::Dump() {
+  /*
+    std::string flattening_state_str;
+    switch (flattenning_state_) {
+      case ClientFlattenningState::Disabled:
+        flattening_state_str = "Disabled";
+        break;
+      case ClientFlattenningState::NotRequired:
+        flattening_state_str = "Not needed";
+        break;
+      case ClientFlattenningState::Flattened:
+        flattening_state_str = "Active";
+        break;
+      case ClientFlattenningState::ClientRefreshRequested:
+        flattening_state_str = "Refresh requested";
+        break;
+      default:
+        flattening_state_str = std::to_string(flattenning_state_) +
+                               " VSync remains";
+    }
+  */
   auto connector_name = IsInHeadlessMode()
                             ? std::string("NULL-DISPLAY")
                             : GetPipe().connector->Get()->GetName();
 
   std::stringstream ss;
-  ss << "- Display on: " << connector_name << "\n"
-     << "Statistics since system boot:\n"
-     << DumpDelta(total_stats_) << "\n\n"
-     << "Statistics since last dumpsys request:\n"
-     << DumpDelta(total_stats_.minus(prev_stats_)) << "\n\n";
+  ss << "- Display on: " << connector_name << "\n";
+  ss << "Compositor:\n";
+  if (compositor_)
+    ss << compositor_->Dump() << "\n\n";
 
-  memcpy(&prev_stats_, &total_stats_, sizeof(Stats));
   return ss.str();
 }
 
@@ -118,12 +114,7 @@ void HwcDisplay::Deinit() {
     GetPipe().atomic_state_manager->ExecuteAtomicCommit(a_args);
 #endif
 
-    current_plan_.reset();
-    backend_.reset();
-    if (flatcon_) {
-      flatcon_->StopThread();
-      flatcon_.reset();
-    }
+    compositor_.reset();
   }
 
   if (vsync_worker_) {
@@ -167,18 +158,22 @@ HWC2::Error HwcDisplay::Init() {
   }
 
   if (!IsInHeadlessMode()) {
-    auto ret = BackendManager::GetInstance().SetBackendForDisplay(this);
-    if (ret) {
-      ALOGE("Failed to set backend for d=%d %d\n", int(handle_), ret);
+    auto backend_callbacks = (struct CompositorCallbacks){
+        .update_layer_data = [](FELayer &l, bool test_only) -> bool {
+          return ToHwcLayer(l).PopulateLayerData(test_only);
+        },
+        .update_composition = [this]() -> void {
+          if (hwc2_->refresh_callback_.first != nullptr &&
+              hwc2_->refresh_callback_.second != nullptr)
+            hwc2_->refresh_callback_.first(hwc2_->refresh_callback_.second,
+                                           handle_);
+        },
+    };
+    compositor_ = CompositorBase::FindAndCreate(GetPipe(), backend_callbacks);
+    if (!compositor_) {
+      ALOGE("Failed to set backend for d=%d", int(handle_));
       return HWC2::Error::BadDisplay;
     }
-    auto flatcbk = (struct FlatConCallbacks){.trigger = [this]() {
-      if (hwc2_->refresh_callback_.first != nullptr &&
-          hwc2_->refresh_callback_.second != nullptr)
-        hwc2_->refresh_callback_.first(hwc2_->refresh_callback_.second,
-                                       handle_);
-    }};
-    flatcon_ = FlatteningController::CreateInstance(flatcbk);
   }
 
   ToHwcLayer(*client_output).SetLayerBlendMode(HWC2_BLEND_MODE_PREMULTIPLIED);
@@ -449,12 +444,16 @@ HWC2::Error HwcDisplay::GetReleaseFences(uint32_t *num_elements,
   return HWC2::Error::None;
 }
 
-HWC2::Error HwcDisplay::CreateComposition(AtomicCommitArgs &a_args) {
+/* Find API details at:
+ * https://cs.android.com/android/platform/superproject/+/android-11.0.0_r3:hardware/libhardware/include/hardware/hwcomposer2.h;l=1805
+ */
+HWC2::Error HwcDisplay::PresentDisplay(int32_t *out_present_fence) {
   if (IsInHeadlessMode()) {
-    ALOGE("%s: Display is in headless mode, should never reach here", __func__);
+    *out_present_fence = -1;
     return HWC2::Error::None;
   }
 
+  AtomicCommitArgs a_args{};
   uint32_t prev_vperiod_ns = 0;
   GetDisplayVsyncPeriod(&prev_vperiod_ns);
 
@@ -476,74 +475,9 @@ HWC2::Error HwcDisplay::CreateComposition(AtomicCommitArgs &a_args) {
     }
   }
 
-  // order the layers by z-order
-  bool use_client_layer = false;
-  uint32_t client_z_order = UINT32_MAX;
-  std::map<uint32_t, std::shared_ptr<FELayer>> z_map;
-  for (auto &fl : fe_layers) {
-    auto &l = ToHwcLayer(*fl.second);
-    switch (l.GetValidatedType()) {
-      case HWC2::Composition::Device:
-        z_map.emplace(l.zpos, fl.second);
-        break;
-      case HWC2::Composition::Client:
-        // Place it at the z_order of the lowest client layer
-        use_client_layer = true;
-        client_z_order = std::min(client_z_order, l.zpos);
-        break;
-      default:
-        continue;
-    }
-  }
-  if (use_client_layer)
-    z_map.emplace(client_z_order, client_output);
-
-  if (z_map.empty())
+  if (compositor_->PresentComposition(*this, a_args) != 0) {
+    *out_present_fence = -1;
     return HWC2::Error::BadLayer;
-
-  std::vector<LayerData> composition_layers;
-
-  /* Import & populate */
-  for (auto &zm : z_map) {
-    ToHwcLayer(*zm.second).PopulateLayerData(a_args.test_only);
-  }
-
-  // now that they're ordered by z, add them to the composition
-  for (auto &zm : z_map) {
-    auto &l = ToHwcLayer(*zm.second);
-    if (!l.IsLayerUsableAsDevice()) {
-      /* This will be normally triggered on validation of the first frame
-       * containing CLIENT layer. At this moment client buffer is not yet
-       * provided by the CLIENT.
-       * This may be triggered once in HwcLayer lifecycle in case FB can't be
-       * imported. For example when non-contiguous buffer is imported into
-       * contiguous-only DRM/KMS driver.
-       */
-      return HWC2::Error::BadLayer;
-    }
-    composition_layers.emplace_back(l.layer_data.Clone());
-  }
-
-  /* Store plan to ensure shared planes won't be stolen by other display
-   * in between of ValidateDisplay() and PresentDisplay() calls
-   */
-  current_plan_ = DrmKmsPlan::CreateDrmKmsPlan(GetPipe(),
-                                               std::move(composition_layers));
-  if (!current_plan_) {
-    if (!a_args.test_only) {
-      ALOGE("Failed to create DrmKmsPlan");
-    }
-    return HWC2::Error::BadConfig;
-  }
-
-  a_args.composition = current_plan_;
-
-  auto ret = GetPipe().atomic_state_manager->ExecuteAtomicCommit(a_args);
-
-  if (ret) {
-    if (!a_args.test_only)
-      ALOGE("Failed to apply the frame composition ret=%d", ret);
-    return HWC2::Error::BadParameter;
   }
 
   if (mode_update_commited_) {
@@ -556,39 +490,9 @@ HWC2::Error HwcDisplay::CreateComposition(AtomicCommitArgs &a_args) {
     }
   }
 
-  return HWC2::Error::None;
-}
-
-/* Find API details at:
- * https://cs.android.com/android/platform/superproject/+/android-11.0.0_r3:hardware/libhardware/include/hardware/hwcomposer2.h;l=1805
- */
-HWC2::Error HwcDisplay::PresentDisplay(int32_t *out_present_fence) {
-  if (IsInHeadlessMode()) {
-    *out_present_fence = -1;
-    return HWC2::Error::None;
-  }
-  HWC2::Error ret{};
-
-  ++total_stats_.total_frames_;
-
-  AtomicCommitArgs a_args{};
-  ret = CreateComposition(a_args);
-
-  if (ret != HWC2::Error::None)
-    ++total_stats_.failed_kms_present_;
-
-  if (ret == HWC2::Error::BadLayer) {
-    // Can we really have no client or device layers?
-    *out_present_fence = -1;
-    return HWC2::Error::None;
-  }
-  if (ret != HWC2::Error::None)
-    return ret;
-
   this->present_fence_ = UniqueFd::Dup(a_args.out_fence.Get());
   *out_present_fence = a_args.out_fence.Release();
 
-  ++frame_no_;
   return HWC2::Error::None;
 }
 
@@ -634,8 +538,7 @@ HWC2::Error HwcDisplay::SetClientTarget(buffer_handle_t target,
     return HWC2::Error::None;
   }
 
-  ToHwcLayer(*client_output).PopulateLayerData(/*test = */ true);
-  if (!ToHwcLayer(*client_output).IsLayerUsableAsDevice()) {
+  if (!ToHwcLayer(*client_output).PopulateLayerData(/*test = */ true)) {
     ALOGE("Client layer must be always usable by DRM/KMS");
     return HWC2::Error::BadLayer;
   }
@@ -749,7 +652,7 @@ HWC2::Error HwcDisplay::ValidateDisplay(uint32_t *num_types,
   bool force_client{};
   if (color_transform_hint() != HAL_COLOR_TRANSFORM_IDENTITY) {
     ALOGV("Can't scanout. CTM isn't supported yet.");
-    force_client = true;
+    // force_client = true;
   }
 
   for (auto &fl : fe_layers) {
@@ -765,7 +668,7 @@ HWC2::Error HwcDisplay::ValidateDisplay(uint32_t *num_types,
                                 HWC2::Composition::Client);
   }
 
-  backend_->ValidateComposition(*this);
+  compositor_->ValidateComposition(*this);
 
   for (auto &fl : fe_layers) {
     auto &l = ToHwcLayer(*fl.second);
@@ -948,12 +851,4 @@ HWC2::Error HwcDisplay::SetColorModeWithIntent(int32_t mode, int32_t intent) {
 
 #endif /* __ANDROID_API__ > 27 */
 
-const Backend *HwcDisplay::backend() const {
-  return backend_.get();
-}
-
-void HwcDisplay::set_backend(std::unique_ptr<Backend> backend) {
-  backend_ = std::move(backend);
-}
-
 }  // namespace android
diff --git a/hwc2_device/HwcDisplay.h b/hwc2_device/HwcDisplay.h
index ba5bfc68124707..848e4a30e19df8 100644
--- a/hwc2_device/HwcDisplay.h
+++ b/hwc2_device/HwcDisplay.h
@@ -23,8 +23,8 @@
 #include <sstream>
 
 #include "HwcDisplayConfigs.h"
+#include "compositor/CompositorBase.h"
 #include "compositor/FEComposition.h"
-#include "compositor/FlatteningController.h"
 #include "drm/DrmAtomicStateManager.h"
 #include "drm/ResourceManager.h"
 #include "drm/VSyncWorker.h"
@@ -32,7 +32,6 @@
 
 namespace android {
 
-class Backend;
 class DrmHwcTwo;
 
 inline constexpr uint32_t kPrimaryDisplay = 0;
@@ -126,28 +125,6 @@ class HwcDisplay : public FEComposition {
     return static_cast<HwcLayer *>(fe_layers[layer].get());
   }
 
-  /* Statistics */
-  struct Stats {
-    Stats minus(Stats b) const {
-      return {total_frames_ - b.total_frames_,
-              total_pixops_ - b.total_pixops_,
-              gpu_pixops_ - b.gpu_pixops_,
-              failed_kms_validate_ - b.failed_kms_validate_,
-              failed_kms_present_ - b.failed_kms_present_,
-              frames_flattened_ - b.frames_flattened_};
-    }
-
-    uint32_t total_frames_ = 0;
-    uint64_t total_pixops_ = 0;
-    uint64_t gpu_pixops_ = 0;
-    uint32_t failed_kms_validate_ = 0;
-    uint32_t failed_kms_present_ = 0;
-    uint32_t frames_flattened_ = 0;
-  };
-
-  const Backend *backend() const;
-  void set_backend(std::unique_ptr<Backend> backend);
-
   auto GetHwc2() {
     return hwc2_;
   }
@@ -160,9 +137,7 @@ class HwcDisplay : public FEComposition {
     return color_transform_hint_;
   }
 
-  Stats &total_stats() {
-    return total_stats_;
-  }
+  void ProcessFlatenningVsyncInternal();
 
   /* Headless mode required to keep SurfaceFlinger alive when all display are
    * disconnected, Without headless mode Android will continuously crash.
@@ -176,10 +151,6 @@ class HwcDisplay : public FEComposition {
 
   void Deinit();
 
-  auto GetFlatCon() {
-    return flatcon_;
-  }
-
  private:
   constexpr static size_t MATRIX_SIZE = 16;
 
@@ -195,8 +166,7 @@ class HwcDisplay : public FEComposition {
 
   DrmDisplayPipeline *pipeline_{};
 
-  std::unique_ptr<Backend> backend_;
-  std::shared_ptr<FlatteningController> flatcon_;
+  std::unique_ptr<CompositorBase> compositor_;
 
   std::shared_ptr<VSyncWorker> vsync_worker_;
   bool vsync_event_en_{};
@@ -212,13 +182,6 @@ class HwcDisplay : public FEComposition {
   std::array<float, MATRIX_SIZE> color_transform_matrix_{};
   android_color_transform_t color_transform_hint_;
 
-  std::shared_ptr<DrmKmsPlan> current_plan_;
-
-  uint32_t frame_no_ = 0;
-  Stats total_stats_;
-  Stats prev_stats_;
-  std::string DumpDelta(HwcDisplay::Stats delta);
-
   HWC2::Error Init();
 
   HWC2::Error SetActiveConfigInternal(uint32_t config, int64_t change_time);
diff --git a/hwc2_device/HwcLayer.cpp b/hwc2_device/HwcLayer.cpp
index e84d801ea6a004..167ad3885232e3 100644
--- a/hwc2_device/HwcLayer.cpp
+++ b/hwc2_device/HwcLayer.cpp
@@ -233,12 +233,12 @@ void HwcLayer::ImportFb() {
   }
 }
 
-void HwcLayer::PopulateLayerData(bool test) {
+bool HwcLayer::PopulateLayerData(bool test) {
   ImportFb();
 
   if (!layer_data.bi) {
     ALOGE("%s: Invalid state", __func__);
-    return;
+    return false;
   }
 
   if (blend_mode_ != BufferBlendMode::kUndefined) {
@@ -254,6 +254,8 @@ void HwcLayer::PopulateLayerData(bool test) {
   if (!test) {
     layer_data.acquire_fence = std::move(acquire_fence_);
   }
+
+  return IsLayerUsableAsDevice();
 }
 
 /* SwapChain Cache */
diff --git a/hwc2_device/HwcLayer.h b/hwc2_device/HwcLayer.h
index a0a0203ebbf4d9..b86dcd4f3c9c1a 100644
--- a/hwc2_device/HwcLayer.h
+++ b/hwc2_device/HwcLayer.h
@@ -100,7 +100,7 @@ class HwcLayer : public FELayer {
 
   /* Layer state */
  public:
-  void PopulateLayerData(bool test);
+  bool PopulateLayerData(bool test);
 
   bool IsLayerUsableAsDevice() const {
     return !bi_get_failed_ && !fb_import_failed_ && buffer_handle_ != nullptr;
diff --git a/hwc2_device/hwc2_device.cpp b/hwc2_device/hwc2_device.cpp
index d4ee10de0da92e..db7f0fd3b9840a 100644
--- a/hwc2_device/hwc2_device.cpp
+++ b/hwc2_device/hwc2_device.cpp
@@ -22,7 +22,6 @@
 #include <cinttypes>
 
 #include "DrmHwcTwo.h"
-#include "backend/Backend.h"
 #include "utils/log.h"
 
 namespace android {
diff --git a/meson.build b/meson.build
index 63d63984be8b5b..c5f3c8b1858242 100644
--- a/meson.build
+++ b/meson.build
@@ -12,9 +12,8 @@ inc_include = [include_directories('.')]
 src_common = files(
     'compositor/DrmKmsPlan.cpp',
     'compositor/FlatteningController.cpp',
-    'backend/BackendManager.cpp',
-    'backend/Backend.cpp',
-    'backend/BackendClient.cpp',
+    'compositor/CompositorBase.cpp',
+    'compositor/CompositorClassic.cpp',
 )
 
 srcs_hwc2_device = [
-- 
2.37.2

